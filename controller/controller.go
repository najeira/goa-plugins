package plugin

import (
	"flag"
	"fmt"
	"os"
	"path"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/goadesign/goa/design"
	"github.com/goadesign/goa/goagen/codegen"
	"github.com/goadesign/goa/goagen/utils"
)

// Generator is the application code generator.
type Generator struct {
	API       *design.APIDefinition // The API definition
	OutDir    string                // Path to output directory
	DesignPkg string                // Path to design package, only used to mark generated files.
	AppPkg    string                // Name of generated "app" package
	Force     bool                  // Whether to override existing files
	Pkg       string                // Name of the generated package
	Resource  string                // Name of the generated file
	genfiles  []string              // Generated files
}

// Generate is the generator entry point called by the meta generator.
func Generate() ([]string, error) {
	var (
		outDir, designPkg, appPkg, ver, res, pkg string
		force                                    bool
	)

	set := flag.NewFlagSet("controller", flag.PanicOnError)
	set.StringVar(&outDir, "out", "", "")
	set.StringVar(&designPkg, "design", "", "")
	set.StringVar(&appPkg, "app-pkg", "app", "")
	set.StringVar(&pkg, "pkg", "controller", "")
	set.StringVar(&res, "res", "", "")
	set.StringVar(&ver, "version", "", "")
	set.BoolVar(&force, "force", false, "")
	set.Parse(os.Args[1:])
	outDir = filepath.Join(outDir, pkg)

	if err := codegen.CheckVersion(ver); err != nil {
		return nil, err
	}

	g := &Generator{
		API:       design.Design,
		OutDir:    outDir,
		DesignPkg: designPkg,
		AppPkg:    appPkg,
		Force:     force,
		Pkg:       pkg,
		Resource:  res,
	}
	return g.Generate()
}

// Generate produces the skeleton controller service factory.
func (g *Generator) Generate() (_ []string, err error) {
	if g.API == nil {
		return nil, fmt.Errorf("missing API definition, make sure design is properly initialized")
	}

	go utils.Catch(nil, func() { g.Cleanup() })

	defer func() {
		if err != nil {
			g.Cleanup()
		}
	}()

	if g.AppPkg == "" {
		g.AppPkg = "app"
	}
	elems := strings.Split(g.AppPkg, "/")
	pkgName := elems[len(elems)-1]
	codegen.Reserved[pkgName] = true

	imports, err := getImports(g.AppPkg, g.OutDir)
	if err != nil {
		return nil, err
	}

	// generate utils_gen.go
	filename, err := generateControllerUtil(g.Force, g.OutDir, g.Pkg, imports)
	if err != nil {
		return nil, err
	}
	g.genfiles = append(g.genfiles, filename)

	appFuncMap := funcMap(pkgName)

	// generate controllers
	err = g.API.IterateResources(func(r *design.ResourceDefinition) error {
		if g.Resource == "" || g.Resource == r.Name {
			scaffoldName, baseName, err := generateController(
				g.Force, g.OutDir, g.Pkg, r.Name, imports, appFuncMap, r)
			if err != nil {
				return err
			}
			g.genfiles = append(g.genfiles, scaffoldName, baseName)
		}
		return nil
	})
	if err != nil {
		return nil, err
	}
	return g.genfiles, err
}

// Cleanup removes all the files generated by this generator during the last invokation of Generate.
func (g *Generator) Cleanup() {
	for _, f := range g.genfiles {
		os.Remove(f)
	}
	g.genfiles = nil
}

func generateController(
	force bool,
	outDir string,
	pkg string,
	name string,
	imports []*codegen.ImportSpec,
	funcMap template.FuncMap,
	r *design.ResourceDefinition) (string, string, error) {

	// generate scaffold
	scaffoldName := filepath.Join(outDir, codegen.SnakeCase(name)+".go")
	scaffoldFile, err := sourceFileFor(force, outDir, scaffoldName)
	if scaffoldFile == nil || err != nil {
		return "", "", err
	}
	if err := generateControllerScaffold(scaffoldFile, pkg, imports, funcMap, r); err != nil {
		return "", "", err
	}

	// generate controller definition
	genName := filepath.Join(outDir, codegen.SnakeCase(name)+"_gen.go")
	genFile, err := sourceFileFor(force, outDir, genName)
	if genFile == nil || err != nil {
		return "", "", err
	}
	if err := generateControllerDefinition(genFile, pkg, imports, funcMap, r); err != nil {
		return "", "", err
	}

	return scaffoldName, genName, nil
}

func generateControllerDefinition(
	file *codegen.SourceFile,
	pkg string,
	imports []*codegen.ImportSpec,
	funcMap template.FuncMap,
	r *design.ResourceDefinition) error {
	title := fmt.Sprintf("%sControllers", codegen.Goify(r.Name, true))
	file.WriteHeader(title, pkg, imports)
	if err := file.ExecuteTemplate("controller", ctrlT, funcMap, r); err != nil {
		return err
	}
	err := r.IterateActions(func(a *design.ActionDefinition) error {
		name := "action"
		tmpl := actionT
		if a.WebSocket() {
			name = "actionWS"
			tmpl = actionWST
		}
		return file.ExecuteTemplate(name, tmpl, funcMap, a)
	})
	if err != nil {
		return err
	}
	return file.FormatCode()
}

func generateControllerScaffold(
	file *codegen.SourceFile,
	pkg string,
	imports []*codegen.ImportSpec,
	funcMap template.FuncMap,
	r *design.ResourceDefinition) error {
	file.WriteHeader("", pkg, imports)
	err := r.IterateActions(func(a *design.ActionDefinition) error {
		return file.ExecuteTemplate("doAction", doActionT, funcMap, a)
	})
	if err != nil {
		return err
	}
	return file.FormatCode()
}

func generateControllerUtil(
	force bool,
	outDir string,
	pkg string,
	imports []*codegen.ImportSpec) (string, error) {
	filename := filepath.Join(outDir, "utils_gen.go")
	file, err := sourceFileFor(force, outDir, filename)
	if file == nil || err != nil {
		return "", err
	}
	title := fmt.Sprintf("%s utilities", pkg)
	file.WriteHeader(title, pkg, imports)
	if err = file.ExecuteTemplate("utils", utilsT, nil, nil); err != nil {
		return "", err
	}
	if err = file.FormatCode(); err != nil {
		return "", err
	}
	return filename, nil
}

func sourceFileFor(force bool, outDir, filename string) (*codegen.SourceFile, error) {
	if force {
		os.Remove(filename)
	}
	if _, e := os.Stat(filename); e == nil {
		return nil, nil
	}
	if err := os.MkdirAll(outDir, 0755); err != nil {
		return nil, err
	}
	return codegen.SourceFileFor(filename)
}

func getImports(appPkg, outDir string) ([]*codegen.ImportSpec, error) {
	impName := appPkg
	if _, err := codegen.PackageSourcePath(appPkg); err != nil {
		pkgPath, err := codegen.PackagePath(outDir)
		if err != nil {
			return nil, err
		}
		impName = path.Join(filepath.ToSlash(pkgPath), appPkg)
	}
	imports := []*codegen.ImportSpec{
		codegen.SimpleImport("io"),
		codegen.SimpleImport("github.com/goadesign/goa"),
		codegen.SimpleImport(impName),
		codegen.SimpleImport("golang.org/x/net/websocket"),
	}
	return imports, nil
}

func getOkResp(a *design.ActionDefinition) *design.ResponseDefinition {
	for _, resp := range a.Responses {
		if resp.Status == 200 {
			return resp
		}
	}
	return nil
}

func getOkRespMap(a *design.ActionDefinition, appPkg string) map[string]interface{} {
	resp := getOkResp(a)
	if resp == nil {
		return nil
	}

	mediaTypeName := design.CanonicalIdentifier(resp.MediaType)
	mediaType, ok := design.Design.MediaTypes[mediaTypeName]
	if !ok {
		return nil
	}

	viewName := resp.ViewName
	if viewName == "" {
		viewName = design.DefaultView
	}
	pmt, _, err := mediaType.Project(viewName)
	if err != nil {
		return nil
	}

	var typeof string = "interface{}"
	var typeref string
	if pmt.IsError() {
		typeref = `goa.ErrInternal("not implemented")`
	} else {
		name := codegen.GoTypeRef(pmt, pmt.AllRequired(), 1, false)
		var pointer string
		if strings.HasPrefix(name, "*") {
			name = name[1:]
			pointer = "*"
		}
		typeof = fmt.Sprintf("%s%s.%s", pointer, appPkg, name)
		if strings.HasPrefix(typeof, "*") {
			typeref = "&" + typeof[1:]
		}
		typeref += "{}"
	}

	var nameSuffix string
	if viewName != "default" {
		nameSuffix = codegen.Goify(viewName, true)
	}

	return map[string]interface{}{
		"Name":    resp.Name + nameSuffix,
		"TypeRef": typeref,
		"TypeOf":  typeof,
	}
}

// funcMap creates the funcMap used to render the controller code.
func funcMap(appPkg string) template.FuncMap {
	return template.FuncMap{
		"okResp":    getOkRespMap,
		"targetPkg": func() string { return appPkg },
	}
}

const ctrlT = `// {{ $ctrlName := printf "%s%s" (goify .Name true) "Controller" }}{{ $ctrlName }} implements the {{ .Name }} resource.
type {{ $ctrlName }} struct {
	*goa.Controller
}

// New{{ $ctrlName }} creates a {{ .Name }} controller.
func New{{ $ctrlName }}(service *goa.Service) *{{ $ctrlName }} {
	return &{{ $ctrlName }}{Controller: service.NewController("{{ $ctrlName }}")}
}
`

const actionT = `{{ $ctrlName := printf "%s%s" (goify .Parent.Name true) "Controller" }}// {{ goify .Name true }} runs the {{ .Name }} action.
func (c *{{ $ctrlName }}) {{ goify .Name true }}(ctx *{{ targetPkg }}.{{ goify .Name true }}{{ goify .Parent.Name true }}Context) error {
	result, err := c.Do{{ goify .Name true }}(ctx)
	if err != nil {
		return SendError(ctx, err)
	}
	return ctx.{{ $ok := okResp . targetPkg }}{{ if $ok }}{{ $ok.Name }}{{ else }}OK{{ end }}(result)
}
`

const doActionT = `{{ $ctrlName := printf "%s%s" (goify .Parent.Name true) "Controller" }}// Do{{ goify .Name true }} runs the {{ .Name }} action.
func (c *{{ $ctrlName }}) Do{{ goify .Name true }}(ctx *{{ targetPkg }}.{{ goify .Name true }}{{ goify .Parent.Name true }}Context) ({{ $ok := okResp . targetPkg }}{{ if $ok }}{{ $ok.TypeOf }}{{ else }}[]byte{{ end }}, error) {
	// Put your logic here

	return {{ if $ok }}{{ $ok.TypeRef }}{{ else }}nil{{ end }}, nil
}
`

const actionWST = `{{ $ctrlName := printf "%s%s" (goify .Parent.Name true) "Controller" }}// {{ goify .Name true }} runs the {{ .Name }} action.
func (c *{{ $ctrlName }}) {{ goify .Name true }}(ctx *{{ targetPkg }}.{{ goify .Name true }}{{ goify .Parent.Name true }}Context) error {
	c.{{ goify .Name true }}WSHandler(ctx).ServeHTTP(ctx.ResponseWriter, ctx.Request)
	return nil
}

// {{ goify .Name true }}WSHandler establishes a websocket connection to run the {{ .Name }} action.
func (c *{{ $ctrlName }}) {{ goify .Name true }}WSHandler(ctx *{{ targetPkg }}.{{ goify .Name true }}{{ goify .Parent.Name true }}Context) websocket.Handler {
	return func(ws *websocket.Conn) {
		// Put your logic here

		ws.Write([]byte("{{ .Name }} {{ .Parent.Name }}"))
		// Dummy echo websocket server
		io.Copy(ws, ws)
	}
}`

const utilsT = `
// BadRequestSender sends a HTTP response with status code 400.
type BadRequestSender interface {
	BadRequest(error) error
}

// UnauthorizedSender sends a HTTP response with status code 401.
type UnauthorizedSender interface {
	Unauthorized(error) error
}

// ForbiddenSender sends a HTTP response with status code 403.
type ForbiddenSender interface {
	Forbidden(error) error
}

// NotFoundSender sends a HTTP response with status code 404.
type NotFoundSender interface {
	NotFound(error) error
}

// InternalServerErrorSender sends a HTTP response with status code 500.
type InternalServerErrorSender interface {
	InternalServerError(error) error
}

// ServiceUnavailableSender sends a HTTP response with status code 503.
type ServiceUnavailableSender interface {
	ServiceUnavailable(error) error
}

// SendError sends a HTTP response with the error.
func SendError(ctx interface{}, err error) error {
	gerr, ok := err.(*goa.ErrorResponse)
	if !ok {
		return err
	}
	switch gerr.Status {
	case 400:
		if sender, ok := ctx.(BadRequestSender); ok {
			return sender.BadRequest(gerr)
		}
	case 401:
		if sender, ok := ctx.(UnauthorizedSender); ok {
			return sender.Unauthorized(gerr)
		}
	case 403:
		if sender, ok := ctx.(ForbiddenSender); ok {
			return sender.Forbidden(gerr)
		}
	case 404:
		if sender, ok := ctx.(NotFoundSender); ok {
			return sender.NotFound(gerr)
		}
	case 500:
		if sender, ok := ctx.(InternalServerErrorSender); ok {
			return sender.InternalServerError(gerr)
		}
	case 503:
		if sender, ok := ctx.(ServiceUnavailableSender); ok {
			return sender.ServiceUnavailable(gerr)
		}
	}
	return err
}
`
